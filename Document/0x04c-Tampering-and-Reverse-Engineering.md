## Tampering and Reverse Engineering

リバースエンジニアリングや改ざんに関する技術は長らく、クラッカー、モッダー、マルウェアアナリストらの扱う領域でした。「伝統的な」セキュリティテスターや研究者にとって、リバースエンジニアリングはあくまでも補完的なスキルに過ぎませんでした。しかし、潮目が変わりつつあります。モバイルアプリケーションのブラックボックステストでは、コンパイルされたアプリケーションを逆アセンブルし、パッチを適用し、バイナリコードやライブプロセスを改ざんするといった必要性がますます高まっています。多くのモバイルアプリケーションが改ざん対策を施しているという事実は、セキュリティテスターに​​とっては厄介なことです。。

モバイルアプリのリバースエンジニアリングは、コンパイルされたアプリを分析し、ソースコードに関する情報を抽出するプロセスです。リバースエンジニアリングの目的はコードの *理解* にあります。

*改ざん* は、モバイルアプリ（コンパイルされたアプリまたは実行中のプロセス）またはその環境を、その動作に影響するように変更するプロセスです。たとえば、アプリがroot化された端末での実行を拒否し、テストの一部を実行できないといったことがあります。そのような場合には、アプリの動作を変更する必要があります。

モバイルセキュリティテスターは、基本的なリバースエンジニアリングの概念を理解することでよりよいテストが可能になります。また、プロセッサアーキテクチャ、実行形式、プログラミング言語の複雑さなど、モバイルデバイスとオペレーティングシステムを理解する必要があります。

リバースエンジニアリングは芸術であり、そのすべての側面を記述しようとすると紙面がいくらあっても足りません。リバースエンジニアリングに関して必要となる技術と専門分野の広さは驚異的です。マルウェア分析の自動化や難解な難読化手法の開発など、非常に特殊で孤立した問題に何年も費やすこともあります。セキュリティテスターはジェネラリストです。効果的なリバースエンジニアであるためには、膨大な量の関連情報をフィルタリングする必要があります。

どんな局面にでも通用するような一般的なリバースエンジニアリングプロセスはありません。それでは、このガイドの後半でよく使われる方法とツールについて説明し、最も一般的な対策について述べていきます。

### Why You Need It

モバイルセキュリティテストには、いくつかの理由から少なくとも基本的なリバースエンジニアリングスキルが必要です。

**1.To enable black-box testing of mobile apps.** 最近のアプリには、動的解析を妨げるコントロールが含まれることが多い。SSLピニングとエンドツーエンド(E2E)暗号化が施されていると、プロキシを使用したトラフィックのインターセプトや操作などができなくなったりします。root化端末の検出機能があると、アプリがroot化した端末上で実行できなくなるため、高度なテストツールを使用できなくなる可能性があります。そのため、これらの対策を無効にする必要があります。

**2.To enhance static analysis in black-box security testing** ブラックボックステストでは、アプリケーションのバイトコードまたはバイナリコードの静的解析により、アプリケーションの内部ロジックを理解するのに役立ちます。また、ハードコードされた資格情報などの欠陥を特定することもできます。

**3. To assess resilience against reverse engineering.** the Mobile Application Security Verification Standard Anti-Reversing Controls(MASVS-R)に記載されているソフトウェア保護対策を実装しているアプリケーションは、ある程度リバースエンジニアリングに耐えなければなりません。このような保護対策の有効性を検証するために、テスターは一般的なセキュリティテストの一環として *レジリエンスアセスメント* を実行することがあります。レジリアンスアセスメントでは、テスターはリバースエンジニアの役割を引き受け、その保護対策をバイパスできるか試みます。

私たちがモバイルアプリの世界に飛び込む前に、良いニュースと悪いニュースがあります。良いニュースから始めましょう：

**最終的に、リバースエンジニアが常に勝ちます。**

これは、リバースエンジニアが自然な利点を持っているモバイル業界に特に当てはまります。モバイルアプリのデプロイとサンドボックス化は、従来のデスクトップアプリのデプロイメントやサンドボックス化よりも制限を強めているため、Windowsなどで見られるルートキットのような防御メカニズム(例えば、DRMシステム)は、実現困難になります。Androidのオープン性により、リバースエンジニアはオペレーティングシステムに有利な変更を加えることがでます。iOSはリバースエンジニアにコントロールを与えませんが、保護対策も限られています。

悪いニュースは、マルチスレッドのアンチデバッグコントロール、暗号化ホワイトボックス、改ざん防止機能、非常に複雑なコントロールフローの変換などを扱うことは、決して簡単なことではないということです。最も効果的なソフトウェア保護スキームは独自のもので、標準的な攻撃で破られることはありません。それらを破るには、困難な手動分析、コーディング、フラストレーション、そして-あなたの人格(眠れない夜と緊張関係に応じて)-を必要とします。

初心者が簡単な範囲のリバースエンジニアリングに圧倒されるというのはよくあります。最善の方法は、いくつかの基本的なツールを設定することから始め（the Android and iOS reversingの章を参照）、単純なリバースエンジニアリングのタスクやcrackmeなどから進めていくと良いでしょう。やがてアセンブラ/バイトコード言語、オペレーティングシステム、遭遇する難読化などについて学ぶ必要があります。簡単なタスクから始めて、難しいものまで徐々にレベルアップしていってください。

次のセクションでは、モバイルアプリのセキュリティテストで最も一般的に使用される手法の概要を説明します。後の章では、AndroidとiOSのOS固有の問題について詳しく説明します。

### Basic Tampering Techniques

#### Binary Patching

*パッチ適用* は、バイナリ実行可能ファイル内のコードの変更、Javaバイトコードの変更、またはリソースの改ざんなど、コンパイルされたアプリケーションを変更するプロセスです。 このプロセスは、モバイルゲームのハッキングでは *modding* と呼ばれています。パッチは、16進数エディタでバイナリファイルを編集したり、アプリケーションの逆コンパイル、編集、再アセンブリなど、さまざまな方法で実行できます。有用なパッチの詳細な例は後の章で説明します。

最近のモバイルオペレーティングシステムはコード署名を厳格に施行しているため、修正されたアプリケーションを実行させることは、デスクトップ環境のときのように簡単ではありません。セキュリティ専門家は90年代の方がはるかに楽ちんでした！幸運なことに、あなた自身のデバイスで作業する場合、パッチを適用することはあまり難しくありません。変更されたコードを実行するには、アプリケーションに再署名するか、既定のコード署名検証機能を無効にするだけです。

#### Code Injection

コードインジェクションは、実行時にプロセスを探索および変更できる非常に強力な手法です。インジェクションはさまざまな方法で実装できますが、ドキュメントの充実した自動ツールのお蔭で、詳細を知らなくとも試すことができます。これらのツールを使用すると、プロセスメモリやアプリケーションによってインスタンス化されたライブオブジェクトなどの重要な構造に直接アクセスできます。ロードされたライブラリの解決、メソッドとネイティブ関数のフックなどに役立つ多くのユーティリティ関数が付属しています。プロセスメモリの改ざんは、ファイルの修正などよりも検出が難しいため、ツールの利用が推奨されます。

「Substrate」、「Frida」、および「XPosed」は、モバイル業界で最も広く使用されているフックとコードインジェクションのフレームワークです。3つのフレームワークは、設計思想と実装の詳細が異なります。SubstrateとXposedは、コードインジェクションと/またはフックに焦点を置いており、Fridaは本格的な「動的インスツルメンテーションフレームワーク」を目指しており、コードインジェクション、言語バインディング、および注入可能なJavaScript VMとコンソールを組み込んでいます。

しかし、有名なCydiaのSaurik氏が作成したプログラミング環境(「Cycript-to-JavaScript」コンパイラとも呼ばれる)であるCycriptを注入するためにSubstrateを使ってアプリを計測することもできます。 Fridaの作者は、さらに、["frida-cycript"](https://github.com/nowsecure/frida-cycript "Cycript fork powered by Frida")と呼ばれるCycriptのフォークを作成しました。

3つのフレームワークの例を紹介します。 まずはFridaから始めることをおすすめします。というのも、3つのうち最も汎用性が高いものであるからです。（そのため、Fridaに関する記述と事例に多めに触れています）。特にFridaは、AndroidとiOSの両方のプロセスにJavaScript VMを注入できますが、Substrateを用いたCycriptの注入はiOSのみになります。最終的には、どちらのフレームワークであっても同じ目標を達成することができますが。

### Static and Dynamic Binary Analysis

リバースエンジニアリングは、コンパイルされたプログラムのソースコードの意図を再構築する行為です。 言い換えれば、プログラムを分けて実行し、その一部をシミュレートし、その目的や実装方法などを紐解くということになります。

#### Using Disassemblers and Decompilers

逆アセンブラと逆コンパイラを使用すると、アプリのバイナリコードやバイトコードを多かれ少なかれわかりやすい形式に変換することができます。これらのツールをネイティブのバイナリで使用すると、アプリのアーキテクチャに合致したアセンブラコードを取得できます。AndroidのJavaアプリケーションは、AndroidのJava VMであるdalvikによって使用されるdexフォーマットのアセンブリ言語であるSmaliに逆アセンブルできます。Smaliセンブリは、Javaコードに簡単に逆コンパイルすることができます。

高価で便利なGUIツール、オープンソースの逆アセンブルエンジン、リバースエンジニアリングフレームワークなど、幅広いツールとフレームワークが利用可能です。これらのツールの高度な使用方法は、しばしば書籍になるほどです。使い始める良い方法は、ニーズと予算に合ったツールを選んで、よくレビューされたユーザーガイドを購入することです。OS固有の「Reverse Engineering and Tampering」の章でも、一般的なツールをいくつか紹介します。

#### Debugging and Tracing

伝統的な意味では、デバッグとは、ソフトウェア開発のライフサイクルの一環としてプログラム内の問題を特定し、分離するプロセスです。デバッグに使用されるツールは、バグを特定することが主要な目的ではなくても、リバースエンジニアに非常に役立ちます。デバッガを使用すると、実行中の任意の時点でのプログラムの中断、プロセスの内部状態の検査、さらにはレジスタやメモリの変更が可能になります。 これらの機能はプログラム検査を簡単にしてくれます。

*デバッグ* とは、通常、実行中のプロセスにデバッガが接続されている対話型のデバッグセッションを意味します。対照的に、*トレース* とは、アプリケーションの実行に関する情報（API呼び出しなど）のパッシブロギングを指します。トレースは、デバッグAPI、関数フック、およびカーネルトレース機能を含むいくつかの方法で実行されます。ここでも、OS固有の「Reverse Engineering and Tampering」の章で、これらのテクニックの多くをカバーしています。

### Advanced Techniques

強力な難読化が施されたバイナリを解読するなどといったより複雑なタスクの場合、分析の特定の箇所を自動化することから逃れることはできません。たとえば、逆アセンブラでの手動分析に基づく複雑な制御フローグラフの理解と簡素化には、何年もの月日が必要となります(それに完了するまでに長いこと腹を立てたりすることになります)。代わりに、カスタムメイドのツールを使用してワークフローを強化することができます。幸いにも、現代の逆アセンブラにはスクリプティングと拡張APIが付属しており、一般的な逆アセンブラでは多くの便利な拡張が利用できます。オープンソースの逆アセンブルエンジンとバイナリ分析フレームワークもあります。

ハッキングではいつものように、anything-goのルールが適用されます。最も効率的なものを使用してください。同じバイナリなど一つとしてなく、すべてのリバースエンジニアは独自のスタイルで行われます。多くの場合、目標を達成する最善の方法は、複数のアプローチ(エミュレータベースのトレースやシンボリック実行など)を組み合わせることです。手をつけるには、良い逆アセンブラやリバースエンジニアリングフレームワークを選択してから、特定の機能と拡張APIを快適に使いましょう。結局のところ、より良くなる最良の方法は、実践的な経験を得ることです。

#### Dynamic Binary Instrumentation

ネイティブバイナリへのもう1つの有用なアプローチは、ダイナミックバイナリインストルメンテーション（DBI）です。 ValgrindやPINなどのインストルメンテーションフレームワークは、単一プロセスの細かい命令レベルのトレースをサポートします。これは、実行時に動的に生成されたコードを挿入することによって実現されます。ValgrindはAndroid上でコンパイルを行うことができ、あらかじめ作成されたバイナリがダウンロード可能になっています。

[Valgrind README](http://valgrind.org/docs/manual/dist.readme-android.html "Valgrind README") にはAndroid向けのコンパイル手順が含まれています。

#### Emulation-based Dynamic Analysis

エミュレータ上でアプリケーションを実行すると、その環境をモニターし、操作することができます。いくつかのリバースエンジニアリングのタスク、特に低レベルの命令トレースが必要なリバースエンジニアリングタスクでは、エミュレーションが最良の（または唯一の）選択肢です。残念ながら、iOS用のエミュレータは存在しないため（iOSシミュレータはエミュレータではなく、iOSデバイス用にコンパイルされたアプリケーションは実行されないため）、このタイプの解析はAndroidのみで実行可能です。「Tampering and Reverse Engineering on Android」の章で、Android用の一般的なエミュレーションベースの分析フレームワークの概要を説明します。

#### Custom Tooling with Reverse Engineering Frameworks

ほとんどのなGUIベースのプロ用途な逆アセンブラは、スクリプト機能と拡張性を備えていますが、ある問題の解決にはあまり適していません。リバースエンジニアリングフレームワークを使用すると、重厚なGUIに依存することなく、あらゆる種類のリバースタスクを実行し、また自動化することもできます。特に、ほとんどのリバースフレームワークはオープンソースであり、かつ/もしくは無料で利用可能です。 モバイルアーキテクチャをサポートする一般的なフレームワークには、[Radareand](https://github.com/radare/radare2 "radare2")や[Angr](https://nilocunger.github.io)があります。

##### Example: Program Analysis with Symbolic/Concolic Execution

2000年代後半には、シンボリック実行に基づくテストが、セキュリティ上の脆弱性を識別する一般的な方法となっていました。シンボリック「実行」は、実際には、一次論理の式としてプログラムを通る可能な経路を表現するプロセスを指します。充足可能性判定（SMT）ツールは、これらの式の充足可能性をチェックし、解決された式に対応するパス上の特定の実行点に到達するために必要な変数の具体的な値を含むソリューションを提供します。

通常、シンボリック実行は、古典的なシンボリック実行に特有のパス爆発問題を軽減するために、動的実行などの他の技法と組み合わせられます。この手堅いやり方とシンボリック実行の組み合わせは *concolic実行* (*conc* rete と symb *olic* を組み合わせた造語)と呼ばれます。concolic実行により、SMTソルバーおよび現在のハードウェア速度が改善され、中規模のソフトウェアモジュール（すなわち、10秒程度のKLOC）のパスを探索することが可能になります。しかし、制御フローグラフを単純化するなど難読化タスクをサポートするのにも便利です。例えば、Jonathan SalwanとRomain Thomasは、動的シンボリック実行（すなわち、実際の実行トレース、シミュレーション、およびシンボリック実行の組み合わせを使用して）を使用して、[VMベースのソフトウェア保護をリバースエンジニアリングする方法を示しました](https://triton.quarkslab.com/files/csaw2016-sos-rthomas-jsalwan.pdf "Jonathan Salwan and Romain Thomas: How Triton can help to reverse virtual machine based software protections")。

Androidのセクションでは、シンボリック実行を使用してAndroidアプリケーションの簡単なライセンスチェックをクラックする方法をお伝えします。
